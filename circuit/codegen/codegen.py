#!/usr/bin/env python3

# codegen.py: generate various verilog files for instruction decoding
# from "commands.json", which in turn is generated from "encodings.spec"
# by "parse_encodings.py"

import functools
import json
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from textwrap import dedent

_US = Path(__file__)
_HERE = _US.parent
_COMMANDS_JSON = _HERE / "commands.json"
_COMMANDS_GEN_V = _HERE / "commands.gen.v"
_OPC_MAP_GEN_V = _HERE / "opc_map.gen.v"

_OPND_ENC_MAP = {
    "I": "OPND_ENC_IMM",
    "D": "OPND_ENC_DISP",
    "M": "OPND_ENC_MODREGRM_RM",
    "O": "OPND_ENC_REG",
    "MI": "OPND_ENC_MODREGRM_RM_IMM",
    "MR": "OPND_ENC_MODREGRM_RM_REG",
    "RM": "OPND_ENC_MODREGRM_REG_RM",
    "OI": "OPND_ENC_REG_IMM",
    "AI": "OPND_ENC_EAX_IMM",
    "RMI": "OPND_ENC_MODREGRM_REG_RM_IMM",
    "ZO": "OPND_ENC_NONE",
}


def _header():
    """
    Emit a codegen header.
    """
    return dedent(
        f"""
        // this file was generated by {_US.name} on {datetime.now()}
        // do NOT edit it by hand
        """
    )


def _br(io, n=1):
    print("\n" * n, file=io)


def _paren(thing):
    """
    Parenthesize `thing` if not already parenthesized.

    Why? Makes the generated code slightly easier to read than unconditional parentheticals.
    """
    if thing[0] == "(" and thing[-1] == ")":
        return thing
    else:
        return f"({thing})"


def _asdef(name):
    """
    Emit `name` as a defined macro.
    """
    return f"`{name}"


def _define(name, val):
    """
    Use the `define` macro to define a new macro.
    """
    return f"`define {name} {val}"


def _assign(lhs, rhs):
    """
    Emit an assignment statement.
    """
    return f"assign {lhs} = {rhs};"


def _eq(lhs, rhs):
    """
    Emit an equality expression.
    """
    return f"({_paren(lhs)} == {_paren(rhs)})"


def _opc_eq(rhs):
    """
    Emit an equality expression against the opcode bits of the instruction.
    """
    return _eq("unescaped_instr[7:0]", f"8'h{rhs:x}")


def _opc_ext_eq(rhs):
    """
    Emit an equality expression against the opcode extension bits (reg of ModR/M)
    of the instruction.
    """
    return _eq("unescaped_instr[12:10]", f"3'h{rhs:x}")


def _and(lhs, rhs):
    """
    Emit a logical AND expression.
    """
    return f"({_paren(lhs)} && {_paren(rhs)})"


def _or(lhs, rhs):
    """
    Emit a logical OR expression.
    """
    return f"({_paren(lhs)} ||\n    {_paren(rhs)})"


def _not(expr):
    """
    Emit a logical NOT expression.
    """
    return f"(~{_paren(expr)})"


def _ternary(cond, ifthen, elsethen):
    """
    Emit a ternary expression.
    """
    return f"{_paren(cond)} ?\n    {_paren(ifthen)} :\n    {_paren(elsethen)}"


def _ternary_chain(exprs, lastelsethen):
    """
    Emit a ternary chain, with each leaf evaluating to an opcode command.
    """

    def _ternary_chain_(exprs, lastelsethen):
        if exprs == []:
            return _asdef(lastelsethen)
        else:
            return _ternary(
                exprs[0][1],
                _asdef(exprs[0][0]),
                _ternary_chain_(exprs[1:], lastelsethen),
            )

    return _ternary_chain_(exprs, lastelsethen)


def _gen_commands_v(commands):
    """
    Generate `commands.gen.v`.
    """
    with _COMMANDS_GEN_V.open(mode="w+") as io:
        print(_header(), file=io)
        for idx, cmd in enumerate(commands):
            print(_define(cmd["cmd"], f"6'd{idx}"), file=io)
        print(_define("CMD_UNKNOWN", f"6'd{idx + 1}"), file=io)


def _gen_opc_map_v(commands):
    """
    Generate `opc_map.gen.v`.
    """
    with _OPC_MAP_GEN_V.open(mode="w+") as io:
        print(_header(), file=io)

        # Create the main `opc` assignment.
        cmd_exprs = []
        for cmd in commands:
            enc_exprs = []
            for enc in cmd["encs"]:
                enc_expr = _opc_eq(enc["opc"])
                if enc["esc"]:
                    enc_expr = _and("is_2byte", enc_expr)
                if enc["ext"] is not None:
                    enc_expr = _and(enc_expr, _opc_ext_eq(enc["ext"]))
                enc_exprs.append(enc_expr)
            cmd_expr = functools.reduce(_or, enc_exprs)
            cmd_exprs.append((cmd["cmd"], cmd_expr))
        print(_assign("opc", _ternary_chain(cmd_exprs, "CMD_UNKNOWN")), file=io)

        _br(io, 2)

        # Create a map of operand encoding forms => opcode encoding forms,
        # then use that map to generate the `opnd_form` assignment.
        opnd_enc_map = defaultdict(list)
        for cmd in commands:
            for enc in cmd["encs"]:
                opnd_enc_map[enc["op_enc"]].append(enc)
        opnd_enc_exprs = []
        for opnd_enc, op_encs in opnd_enc_map.items():
            enc_exprs = []
            for op_enc in op_encs:
                enc_expr = _opc_eq(op_enc["opc"])
                if op_enc["esc"]:
                    enc_expr = _and("is_2byte", enc_expr)
                if op_enc["ext"] is not None:
                    enc_expr = _and(enc_expr, _opc_ext_eq(op_enc["ext"]))
                enc_exprs.append(enc_expr)
            opnd_enc_expr = functools.reduce(_or, enc_exprs)
            opnd_enc_exprs.append((_OPND_ENC_MAP[opnd_enc], opnd_enc_expr))
        print(
            _assign(
                "opnd_form", _ternary_chain(opnd_enc_exprs, "OPND_ENC_UNKNOWN")
            ),
            file=io,
        )

        _br(io, 2)

        # Create lists of `rb` and `ib` opcode encoding forms, then use
        # those lists to generate the `reg_1byte` and `imm_1byte` assignments.
        rb_forms = []
        ib_forms = []
        for cmd in commands:
            [rb_forms.append(enc) for enc in cmd["encs"] if enc["rb"]]
            [ib_forms.append(enc) for enc in cmd["encs"] if enc["ib"]]

        rb_form_exprs = []
        for enc in rb_forms:
            rb_form_expr = _opc_eq(enc["opc"])
            if enc["esc"]:
                rb_form_expr = _and("is_2byte", rb_form_expr)
            if enc["ext"] is not None:
                rb_form_expr = _and(rb_form_expr, _opc_ext_eq(enc["ext"]))
            rb_form_exprs.append(rb_form_expr)
        print(_assign("reg_1byte", functools.reduce(_or, rb_form_exprs)), file=io)

        _br(io, 2)

        ib_form_exprs = []
        for enc in ib_forms:
            ib_form_expr = _opc_eq(enc["opc"])
            if enc["esc"]:
                ib_form_expr = _and("is_2byte", ib_form_expr)
            if enc["ext"] is not None:
                ib_form_expr = _and(ib_form_expr, _opc_ext_eq(enc["ext"]))
            ib_form_exprs.append(ib_form_expr)
        print(_assign("imm_1byte", functools.reduce(_or, ib_form_exprs)), file=io)



def main():
    assert _COMMANDS_JSON.exists(), f"codegen dep missing: {_COMMANDS_JSON}"

    commands = json.loads(_COMMANDS_JSON.read_text())

    assert len(commands) < (2 ** 6) - 1, "|commands| > 63; increase the wire size"

    _gen_commands_v(commands)
    _gen_opc_map_v(commands)


if __name__ == "__main__":
    main()
